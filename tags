!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!Go	package	/the real package specified by the package name/
!_TAG_FIELD_DESCRIPTION!Go	packageName	/the name for referring the package/
!_TAG_FIELD_DESCRIPTION!XML	uri	/uri associated with name prefix/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!Ant	P,property	/properties(global)/
!_TAG_KIND_DESCRIPTION!Ant	i,antfile	/antfiles/
!_TAG_KIND_DESCRIPTION!Ant	p,project	/projects/
!_TAG_KIND_DESCRIPTION!Ant	t,target	/targets/
!_TAG_KIND_DESCRIPTION!DTD	E,entity	/entities/
!_TAG_KIND_DESCRIPTION!DTD	a,attribute	/attributes/
!_TAG_KIND_DESCRIPTION!DTD	e,element	/elements/
!_TAG_KIND_DESCRIPTION!DTD	n,notation	/notations/
!_TAG_KIND_DESCRIPTION!DTD	p,parameterEntity	/parameter entities/
!_TAG_KIND_DESCRIPTION!Go	M,anonMember	/struct anonymous members/
!_TAG_KIND_DESCRIPTION!Go	P,packageName	/name for specifying imported package/
!_TAG_KIND_DESCRIPTION!Go	Y,unknown	/unknown/
!_TAG_KIND_DESCRIPTION!Go	a,talias	/type aliases/
!_TAG_KIND_DESCRIPTION!Go	c,const	/constants/
!_TAG_KIND_DESCRIPTION!Go	f,func	/functions/
!_TAG_KIND_DESCRIPTION!Go	i,interface	/interfaces/
!_TAG_KIND_DESCRIPTION!Go	m,member	/struct members/
!_TAG_KIND_DESCRIPTION!Go	n,methodSpec	/interface method specification/
!_TAG_KIND_DESCRIPTION!Go	p,package	/packages/
!_TAG_KIND_DESCRIPTION!Go	s,struct	/structs/
!_TAG_KIND_DESCRIPTION!Go	t,type	/types/
!_TAG_KIND_DESCRIPTION!Go	v,var	/variables/
!_TAG_KIND_DESCRIPTION!Markdown	S,subsection	/level 2 sections/
!_TAG_KIND_DESCRIPTION!Markdown	T,l4subsection	/level 4 sections/
!_TAG_KIND_DESCRIPTION!Markdown	c,chapter	/chapters/
!_TAG_KIND_DESCRIPTION!Markdown	h,hashtag	/hashtags/
!_TAG_KIND_DESCRIPTION!Markdown	n,footnote	/footnotes/
!_TAG_KIND_DESCRIPTION!Markdown	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Markdown	t,subsubsection	/level 3 sections/
!_TAG_KIND_DESCRIPTION!Markdown	u,l5subsection	/level 5 sections/
!_TAG_KIND_DESCRIPTION!XML	i,id	/id attributes/
!_TAG_KIND_DESCRIPTION!XML	n,nsprefix	/namespace prefixes/
!_TAG_KIND_DESCRIPTION!XML	r,root	/root elements/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	1.1	/current.age/
!_TAG_PARSER_VERSION!Ant	0.0	/current.age/
!_TAG_PARSER_VERSION!DTD	0.0	/current.age/
!_TAG_PARSER_VERSION!Go	0.0	/current.age/
!_TAG_PARSER_VERSION!Markdown	1.1	/current.age/
!_TAG_PARSER_VERSION!XML	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/axyl/dev/gocodes/interpreter/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.2.0	/v6.2.0/
!_TAG_ROLE_DESCRIPTION!Ant!antfile	imported	/imported/
!_TAG_ROLE_DESCRIPTION!DTD!element	attOwner	/attributes owner/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	condition	/conditions/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	elementName	/element names/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	partOfAttDef	/part of attribute definition/
!_TAG_ROLE_DESCRIPTION!Go!package	imported	/imported package/
!_TAG_ROLE_DESCRIPTION!Go!unknown	receiverType	/receiver type/
2xqTItjvFA6n28ABagqxqUyFYmJ	.idea/workspace.xml	/^  <component name="ProjectId" id="2xqTItjvFA6n28ABagqxqUyFYmJ" \/>$/;"	i
334cb908-728e-42e4-883b-d69677a969bf	.idea/workspace.xml	/^    <list default="true" id="334cb908-728e-42e4-883b-d69677a969bf" name="Changes" comment="">$/;"	i
ASSIGN	token/token.go	/^	ASSIGN    = "="$/;"	c	package:token
ASTERISK	token/token.go	/^	ASTERISK  = "*"$/;"	c	package:token
Alternative	ast/ast.go	/^	Alternative *BlockStatement$/;"	m	struct:ast.IfExpression	typeref:typename:*BlockStatement
BANG	token/token.go	/^	BANG      = "!"$/;"	c	package:token
BlockStatement	ast/ast.go	/^type BlockStatement struct {$/;"	s	package:ast
Boolean	ast/ast.go	/^type Boolean struct {$/;"	s	package:ast
CALL	parser/parser.go	/^	CALL$/;"	c	package:parser
COMMA	token/token.go	/^	COMMA     = ","$/;"	c	package:token
Condition	ast/ast.go	/^	Condition   Expression$/;"	m	struct:ast.IfExpression	typeref:typename:Expression
Consequence	ast/ast.go	/^	Consequence *BlockStatement$/;"	m	struct:ast.IfExpression	typeref:typename:*BlockStatement
ELSE	token/token.go	/^	ELSE     = "ELSE"$/;"	c	package:token
EOF	token/token.go	/^	EOF     = "EOF"$/;"	c	package:token
EQ	token/token.go	/^	EQ        = "=="$/;"	c	package:token
EQUALS	parser/parser.go	/^	EQUALS$/;"	c	package:parser
Errors	parser/parser.go	/^func (p *Parser) Errors() []string {$/;"	f	struct:parser.Parser	typeref:typename:[]string
Expression	ast/ast.go	/^	Expression Expression$/;"	m	struct:ast.ExpressionStatement	typeref:typename:Expression
Expression	ast/ast.go	/^type Expression interface {$/;"	i	package:ast
ExpressionStatement	ast/ast.go	/^type ExpressionStatement struct {$/;"	s	package:ast
FALSE	token/token.go	/^	FALSE    = "FALSE"$/;"	c	package:token
FUNCTION	token/token.go	/^	FUNCTION = "FUNCTION"$/;"	c	package:token
GT	token/token.go	/^	GT        = ">"$/;"	c	package:token
IDENT	token/token.go	/^	IDENT = "IDENT"$/;"	c	package:token
IF	token/token.go	/^	IF       = "IF"$/;"	c	package:token
ILLEGAL	token/token.go	/^	ILLEGAL = "ILLEGAL"$/;"	c	package:token
INT	token/token.go	/^	INT   = "INT"$/;"	c	package:token
Identifier	ast/ast.go	/^type Identifier struct {$/;"	s	package:ast
IfExpression	ast/ast.go	/^type IfExpression struct {$/;"	s	package:ast
InfixExpression	ast/ast.go	/^type InfixExpression struct {$/;"	s	package:ast
IntegerLiteral	ast/ast.go	/^type IntegerLiteral struct {$/;"	s	package:ast
Interpreter in go	README.md	/^### Interpreter in go$/;"	S
LBRACE	token/token.go	/^	LBRACE    = "{"$/;"	c	package:token
LESSGREATER	parser/parser.go	/^	LESSGREATER$/;"	c	package:parser
LET	token/token.go	/^	LET      = "LET"$/;"	c	package:token
LOWEST	parser/parser.go	/^	LOWEST$/;"	c	package:parser
LPAREN	token/token.go	/^	LPAREN    = "("$/;"	c	package:token
LT	token/token.go	/^	LT        = "<"$/;"	c	package:token
Left	ast/ast.go	/^	Left     Expression$/;"	m	struct:ast.InfixExpression	typeref:typename:Expression
LetStatement	ast/ast.go	/^type LetStatement struct {$/;"	s	package:ast
Lexer	lexer/lexer.go	/^type Lexer struct {$/;"	s	package:lexer
Literal	token/token.go	/^	Literal string$/;"	m	struct:token.Token	typeref:typename:string
LookupIdent	token/token.go	/^func LookupIdent(ident string) TokenType {$/;"	f	package:token	typeref:typename:TokenType
MINUS	token/token.go	/^	MINUS     = "-"$/;"	c	package:token
NOT_EQ	token/token.go	/^	NOT_EQ    = "!="$/;"	c	package:token
Name	ast/ast.go	/^	Name  *Identifier$/;"	m	struct:ast.LetStatement	typeref:typename:*Identifier
New	lexer/lexer.go	/^func New(input string) *Lexer {$/;"	f	package:lexer	typeref:typename:*Lexer
New	parser/parser.go	/^func New(l *lexer.Lexer) *Parser {$/;"	f	package:parser	typeref:typename:*Parser
NextToken	lexer/lexer.go	/^func (l *Lexer) NextToken() token.Token {$/;"	f	struct:lexer.Lexer	typeref:typename:token.Token
Node	ast/ast.go	/^type Node interface {$/;"	i	package:ast
Operator	ast/ast.go	/^	Operator string$/;"	m	struct:ast.InfixExpression	typeref:typename:string
Operator	ast/ast.go	/^	Operator string$/;"	m	struct:ast.PrefixExpression	typeref:typename:string
PLUS	token/token.go	/^	PLUS      = "+"$/;"	c	package:token
PREFIX	parser/parser.go	/^	PREFIX$/;"	c	package:parser
PRODUCT	parser/parser.go	/^	PRODUCT$/;"	c	package:parser
PROMPT	repl/repl.go	/^const PROMPT = ">> "$/;"	c	package:repl
ParseProgram	parser/parser.go	/^func (p *Parser) ParseProgram() *ast.Program {$/;"	f	struct:parser.Parser	typeref:typename:*ast.Program
Parser	parser/parser.go	/^type Parser struct {$/;"	s	package:parser
PrefixExpression	ast/ast.go	/^type PrefixExpression struct {$/;"	s	package:ast
Program	ast/ast.go	/^type Program struct {$/;"	s	package:ast
RBRACE	token/token.go	/^	RBRACE    = "}"$/;"	c	package:token
RETURN	token/token.go	/^	RETURN   = "RETURN"$/;"	c	package:token
RPAREN	token/token.go	/^	RPAREN    = ")"$/;"	c	package:token
ReturnStatement	ast/ast.go	/^type ReturnStatement struct {$/;"	s	package:ast
ReturnValue	ast/ast.go	/^	ReturnValue Expression$/;"	m	struct:ast.ReturnStatement	typeref:typename:Expression
Right	ast/ast.go	/^	Right    Expression$/;"	m	struct:ast.InfixExpression	typeref:typename:Expression
Right	ast/ast.go	/^	Right    Expression$/;"	m	struct:ast.PrefixExpression	typeref:typename:Expression
SEMICOLON	token/token.go	/^	SEMICOLON = ";"$/;"	c	package:token
SLASH	token/token.go	/^	SLASH     = "\/"$/;"	c	package:token
SUM	parser/parser.go	/^	SUM$/;"	c	package:parser
Start	repl/repl.go	/^func Start(in io.Reader, out io.Writer) {$/;"	f	package:repl
Statement	ast/ast.go	/^type Statement interface {$/;"	i	package:ast
Statements	ast/ast.go	/^	Statements []Statement$/;"	m	struct:ast.BlockStatement	typeref:typename:[]Statement
Statements	ast/ast.go	/^	Statements []Statement$/;"	m	struct:ast.Program	typeref:typename:[]Statement
String	ast/ast.go	/^	String() string$/;"	n	interface:ast.Node	typeref:typename:string
String	ast/ast.go	/^func (b *Boolean) String() string       { return b.Token.Literal }$/;"	f	struct:ast.Boolean	typeref:typename:string
String	ast/ast.go	/^func (bs *BlockStatement) String() string {$/;"	f	struct:ast.BlockStatement	typeref:typename:string
String	ast/ast.go	/^func (es *ExpressionStatement) String() string {$/;"	f	struct:ast.ExpressionStatement	typeref:typename:string
String	ast/ast.go	/^func (i *Identifier) String() string       { return i.Value }$/;"	f	struct:ast.Identifier	typeref:typename:string
String	ast/ast.go	/^func (ie *IfExpression) String() string {$/;"	f	struct:ast.IfExpression	typeref:typename:string
String	ast/ast.go	/^func (il *IntegerLiteral) String() string       { return il.Token.Literal }$/;"	f	struct:ast.IntegerLiteral	typeref:typename:string
String	ast/ast.go	/^func (ine *InfixExpression) String() string {$/;"	f	struct:ast.InfixExpression	typeref:typename:string
String	ast/ast.go	/^func (ls *LetStatement) String() string {$/;"	f	struct:ast.LetStatement	typeref:typename:string
String	ast/ast.go	/^func (p *Program) String() string {$/;"	f	struct:ast.Program	typeref:typename:string
String	ast/ast.go	/^func (pe *PrefixExpression) String() string {$/;"	f	struct:ast.PrefixExpression	typeref:typename:string
String	ast/ast.go	/^func (rs *ReturnStatement) String() string {$/;"	f	struct:ast.ReturnStatement	typeref:typename:string
TRUE	token/token.go	/^	TRUE     = "TRUE"$/;"	c	package:token
TestBooleanExpression	parser/parser_test.go	/^func TestBooleanExpression(t *testing.T) {$/;"	f	package:parser
TestIdentifierExpression	parser/parser_test.go	/^func TestIdentifierExpression(t *testing.T) {$/;"	f	package:parser
TestIfExpression	parser/parser_test.go	/^func TestIfExpression(t *testing.T) {$/;"	f	package:parser
TestIntegerLiteralExpression	parser/parser_test.go	/^func TestIntegerLiteralExpression(t *testing.T) {$/;"	f	package:parser
TestLetStatements	parser/parser_test.go	/^func TestLetStatements(t *testing.T) {$/;"	f	package:parser
TestNextToken	lexer/lexer_test.go	/^func TestNextToken(t *testing.T) {$/;"	f	package:lexer
TestOperatorPrecedenceParsing	parser/parser_test.go	/^func TestOperatorPrecedenceParsing(t *testing.T) {$/;"	f	package:parser
TestParsingInfixExpressions	parser/parser_test.go	/^func TestParsingInfixExpressions(t *testing.T) {$/;"	f	package:parser
TestParsingPrefixExpressions	parser/parser_test.go	/^func TestParsingPrefixExpressions(t *testing.T) {$/;"	f	package:parser
TestReturnStatements	parser/parser_test.go	/^func TestReturnStatements(t *testing.T) {$/;"	f	package:parser
TestString	ast/ast_test.go	/^func TestString(t *testing.T) {$/;"	f	package:ast
Token	ast/ast.go	/^	Token       token.Token$/;"	m	struct:ast.IfExpression	typeref:typename:token.Token
Token	ast/ast.go	/^	Token       token.Token$/;"	m	struct:ast.ReturnStatement	typeref:typename:token.Token
Token	ast/ast.go	/^	Token      token.Token$/;"	m	struct:ast.BlockStatement	typeref:typename:token.Token
Token	ast/ast.go	/^	Token      token.Token$/;"	m	struct:ast.ExpressionStatement	typeref:typename:token.Token
Token	ast/ast.go	/^	Token    token.Token$/;"	m	struct:ast.InfixExpression	typeref:typename:token.Token
Token	ast/ast.go	/^	Token    token.Token$/;"	m	struct:ast.PrefixExpression	typeref:typename:token.Token
Token	ast/ast.go	/^	Token token.Token$/;"	m	struct:ast.Boolean	typeref:typename:token.Token
Token	ast/ast.go	/^	Token token.Token$/;"	m	struct:ast.Identifier	typeref:typename:token.Token
Token	ast/ast.go	/^	Token token.Token$/;"	m	struct:ast.IntegerLiteral	typeref:typename:token.Token
Token	ast/ast.go	/^	Token token.Token$/;"	m	struct:ast.LetStatement	typeref:typename:token.Token
Token	token/token.go	/^type Token struct {$/;"	s	package:token
TokenLiteral	ast/ast.go	/^	TokenLiteral() string$/;"	n	interface:ast.Node	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (b *Boolean) TokenLiteral() string { return b.Token.Literal }$/;"	f	struct:ast.Boolean	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (bs *BlockStatement) TokenLiteral() string { return bs.Token.Literal }$/;"	f	struct:ast.BlockStatement	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (es *ExpressionStatement) TokenLiteral() string { return es.Token.Literal }$/;"	f	struct:ast.ExpressionStatement	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (i *Identifier) TokenLiteral() string { return i.Token.Literal }$/;"	f	struct:ast.Identifier	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (ie *IfExpression) TokenLiteral() string { return ie.Token.Literal }$/;"	f	struct:ast.IfExpression	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (il *IntegerLiteral) TokenLiteral() string { return il.Token.Literal }$/;"	f	struct:ast.IntegerLiteral	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (ine *InfixExpression) TokenLiteral() string { return ine.Token.Literal }$/;"	f	struct:ast.InfixExpression	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (ls *LetStatement) TokenLiteral() string { return ls.Token.Literal }$/;"	f	struct:ast.LetStatement	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (p *Program) TokenLiteral() string {$/;"	f	struct:ast.Program	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (pe *PrefixExpression) TokenLiteral() string { return pe.Token.Literal }$/;"	f	struct:ast.PrefixExpression	typeref:typename:string
TokenLiteral	ast/ast.go	/^func (rs *ReturnStatement) TokenLiteral() string { return rs.Token.Literal }$/;"	f	struct:ast.ReturnStatement	typeref:typename:string
TokenType	token/token.go	/^type TokenType string$/;"	t	package:token	typeref:typename:string
Type	token/token.go	/^	Type    TokenType$/;"	m	struct:token.Token	typeref:typename:TokenType
Value	ast/ast.go	/^	Value Expression$/;"	m	struct:ast.LetStatement	typeref:typename:Expression
Value	ast/ast.go	/^	Value bool$/;"	m	struct:ast.Boolean	typeref:typename:bool
Value	ast/ast.go	/^	Value int64$/;"	m	struct:ast.IntegerLiteral	typeref:typename:int64
Value	ast/ast.go	/^	Value string$/;"	m	struct:ast.Identifier	typeref:typename:string
_	parser/parser.go	/^	_ int = iota$/;"	c	package:parser	typeref:typename:int
ast	ast/ast.go	/^package ast$/;"	p
ast	ast/ast_test.go	/^package ast$/;"	p
ch	lexer/lexer.go	/^	ch           byte$/;"	m	struct:lexer.Lexer	typeref:typename:byte
checkParserErrors	parser/parser_test.go	/^func checkParserErrors(t *testing.T, p *Parser) {$/;"	f	package:parser
curPrecedence	parser/parser.go	/^func (p *Parser) curPrecedence() int {$/;"	f	struct:parser.Parser	typeref:typename:int
curToken	parser/parser.go	/^	curToken  token.Token$/;"	m	struct:parser.Parser	typeref:typename:token.Token
curTokenIs	parser/parser.go	/^func (p *Parser) curTokenIs(t token.TokenType) bool {$/;"	f	struct:parser.Parser	typeref:typename:bool
errors	parser/parser.go	/^	errors    []string$/;"	m	struct:parser.Parser	typeref:typename:[]string
expectPeek	parser/parser.go	/^func (p *Parser) expectPeek(t token.TokenType) bool {$/;"	f	struct:parser.Parser	typeref:typename:bool
expressionNode	ast/ast.go	/^	expressionNode()$/;"	n	interface:ast.Expression
expressionNode	ast/ast.go	/^func (b *Boolean) expressionNode()      {}$/;"	f	struct:ast.Boolean
expressionNode	ast/ast.go	/^func (bs *BlockStatement) expressionNode()      {}$/;"	f	struct:ast.BlockStatement
expressionNode	ast/ast.go	/^func (i *Identifier) expressionNode()      {}$/;"	f	struct:ast.Identifier
expressionNode	ast/ast.go	/^func (ie *IfExpression) expressionNode()      {}$/;"	f	struct:ast.IfExpression
expressionNode	ast/ast.go	/^func (il *IntegerLiteral) expressionNode()      {}$/;"	f	struct:ast.IntegerLiteral
expressionNode	ast/ast.go	/^func (ine *InfixExpression) expressionNode()      {}$/;"	f	struct:ast.InfixExpression
expressionNode	ast/ast.go	/^func (pe *PrefixExpression) expressionNode()      {}$/;"	f	struct:ast.PrefixExpression
infixParseFn	parser/parser.go	/^	infixParseFn  func(ast.Expression) ast.Expression$/;"	t	package:parser	typeref:typename:func(ast.Expression) ast.Expression
infixParseFns	parser/parser.go	/^	infixParseFns  map[token.TokenType]infixParseFn$/;"	m	struct:parser.Parser	typeref:typename:map[token.TokenType]infixParseFn
input	lexer/lexer.go	/^	input        string$/;"	m	struct:lexer.Lexer	typeref:typename:string
isDigit	lexer/lexer.go	/^func isDigit(ch byte) bool {$/;"	f	package:lexer	typeref:typename:bool
isLetter	lexer/lexer.go	/^func isLetter(b byte) bool {$/;"	f	package:lexer	typeref:typename:bool
keywords	token/token.go	/^var keywords = map[string]TokenType{$/;"	v	package:token
l	parser/parser.go	/^	l         *lexer.Lexer$/;"	m	struct:parser.Parser	typeref:typename:*lexer.Lexer
lexer	lexer/lexer.go	/^package lexer$/;"	p
lexer	lexer/lexer_test.go	/^package lexer$/;"	p
main	main.go	/^func main() {$/;"	f	package:main
main	main.go	/^package main$/;"	p
newToken	lexer/lexer.go	/^func newToken(tokenType token.TokenType, ch byte) token.Token {$/;"	f	package:lexer	typeref:typename:token.Token
nextToken	parser/parser.go	/^func (p *Parser) nextToken() {$/;"	f	struct:parser.Parser
noPrefixParseFnError	parser/parser.go	/^func (p *Parser) noPrefixParseFnError(t token.TokenType) {$/;"	f	struct:parser.Parser
parseBlockStatement	parser/parser.go	/^func (p *Parser) parseBlockStatement() *ast.BlockStatement {$/;"	f	struct:parser.Parser	typeref:typename:*ast.BlockStatement
parseBoolean	parser/parser.go	/^func (p *Parser) parseBoolean() ast.Expression {$/;"	f	struct:parser.Parser	typeref:typename:ast.Expression
parseExpression	parser/parser.go	/^func (p *Parser) parseExpression(precedence int) ast.Expression {$/;"	f	struct:parser.Parser	typeref:typename:ast.Expression
parseExpressionStatement	parser/parser.go	/^func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {$/;"	f	struct:parser.Parser	typeref:typename:*ast.ExpressionStatement
parseGroupedExpression	parser/parser.go	/^func (p *Parser) parseGroupedExpression() ast.Expression {$/;"	f	struct:parser.Parser	typeref:typename:ast.Expression
parseIdentifier	parser/parser.go	/^func (p *Parser) parseIdentifier() ast.Expression {$/;"	f	struct:parser.Parser	typeref:typename:ast.Expression
parseIfExpression	parser/parser.go	/^func (p *Parser) parseIfExpression() ast.Expression {$/;"	f	struct:parser.Parser	typeref:typename:ast.Expression
parseInfixExpression	parser/parser.go	/^func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {$/;"	f	struct:parser.Parser	typeref:typename:ast.Expression
parseIntegerLiteral	parser/parser.go	/^func (p *Parser) parseIntegerLiteral() ast.Expression {$/;"	f	struct:parser.Parser	typeref:typename:ast.Expression
parseLetStatement	parser/parser.go	/^func (p *Parser) parseLetStatement() *ast.LetStatement {$/;"	f	struct:parser.Parser	typeref:typename:*ast.LetStatement
parsePrefixExpression	parser/parser.go	/^func (p *Parser) parsePrefixExpression() ast.Expression {$/;"	f	struct:parser.Parser	typeref:typename:ast.Expression
parseReturnStatement	parser/parser.go	/^func (p *Parser) parseReturnStatement() *ast.ReturnStatement {$/;"	f	struct:parser.Parser	typeref:typename:*ast.ReturnStatement
parseStatement	parser/parser.go	/^func (p *Parser) parseStatement() ast.Statement {$/;"	f	struct:parser.Parser	typeref:typename:ast.Statement
parser	parser/parser.go	/^package parser$/;"	p
parser	parser/parser_test.go	/^package parser$/;"	p
peekChar	lexer/lexer.go	/^func (l *Lexer) peekChar() byte {$/;"	f	struct:lexer.Lexer	typeref:typename:byte
peekError	parser/parser.go	/^func (p *Parser) peekError(t token.TokenType) {$/;"	f	struct:parser.Parser
peekPrecedence	parser/parser.go	/^func (p *Parser) peekPrecedence() int {$/;"	f	struct:parser.Parser	typeref:typename:int
peekToken	parser/parser.go	/^	peekToken token.Token$/;"	m	struct:parser.Parser	typeref:typename:token.Token
peekTokenIs	parser/parser.go	/^func (p *Parser) peekTokenIs(t token.TokenType) bool {$/;"	f	struct:parser.Parser	typeref:typename:bool
position	lexer/lexer.go	/^	position     int$/;"	m	struct:lexer.Lexer	typeref:typename:int
precedences	parser/parser.go	/^var precedences = map[token.TokenType]int{$/;"	v	package:parser
prefixParseFn	parser/parser.go	/^	prefixParseFn func() ast.Expression$/;"	t	package:parser	typeref:typename:func() ast.Expression
prefixParseFns	parser/parser.go	/^	prefixParseFns map[token.TokenType]prefixParseFn$/;"	m	struct:parser.Parser	typeref:typename:map[token.TokenType]prefixParseFn
readChar	lexer/lexer.go	/^func (l *Lexer) readChar() {$/;"	f	struct:lexer.Lexer
readIdentifier	lexer/lexer.go	/^func (l *Lexer) readIdentifier() string {$/;"	f	struct:lexer.Lexer	typeref:typename:string
readNumber	lexer/lexer.go	/^func (l *Lexer) readNumber() string {$/;"	f	struct:lexer.Lexer	typeref:typename:string
readPosition	lexer/lexer.go	/^	readPosition int$/;"	m	struct:lexer.Lexer	typeref:typename:int
registerInfix	parser/parser.go	/^func (p *Parser) registerInfix(tokenType token.TokenType, fn infixParseFn) {$/;"	f	struct:parser.Parser
registerPrefix	parser/parser.go	/^func (p *Parser) registerPrefix(tokenType token.TokenType, fn prefixParseFn) {$/;"	f	struct:parser.Parser
repl	repl/repl.go	/^package repl$/;"	p
skipWhitespace	lexer/lexer.go	/^func (l *Lexer) skipWhitespace() {$/;"	f	struct:lexer.Lexer
statementNode	ast/ast.go	/^	statementNode()$/;"	n	interface:ast.Statement
statementNode	ast/ast.go	/^func (es *ExpressionStatement) statementNode()       {}$/;"	f	struct:ast.ExpressionStatement
statementNode	ast/ast.go	/^func (ls *LetStatement) statementNode()       {}$/;"	f	struct:ast.LetStatement
statementNode	ast/ast.go	/^func (rs *ReturnStatement) statementNode()       {}$/;"	f	struct:ast.ReturnStatement
testBooleanLiteral	parser/parser_test.go	/^func testBooleanLiteral(t *testing.T, exp ast.Expression, value bool) bool {$/;"	f	package:parser	typeref:typename:bool
testIdentifier	parser/parser_test.go	/^func testIdentifier(t *testing.T, exp ast.Expression, value string) bool {$/;"	f	package:parser	typeref:typename:bool
testInfixExpression	parser/parser_test.go	/^func testInfixExpression(t *testing.T, exp ast.Expression, left any, operator string, right any)/;"	f	package:parser	typeref:typename:bool
testIntegerLiteral	parser/parser_test.go	/^func testIntegerLiteral(t *testing.T, il ast.Expression, value int64) bool {$/;"	f	package:parser	typeref:typename:bool
testLetStatements	parser/parser_test.go	/^func testLetStatements(t *testing.T, s ast.Statement, name string) bool {$/;"	f	package:parser	typeref:typename:bool
testLiteralExpression	parser/parser_test.go	/^func testLiteralExpression(t *testing.T, exp ast.Expression, expected any) bool {$/;"	f	package:parser	typeref:typename:bool
token	token/token.go	/^package token$/;"	p
